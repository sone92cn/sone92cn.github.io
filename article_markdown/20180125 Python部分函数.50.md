## numpy.tile:
numpy.tile(A, reps):Array Copy
If reps has length d, the result will have dimension of **max(d, A.ndim)**;If **A.ndim < d**, A is promoted to be d-dimensional by **prepending** new axes;If **A.ndim > d**, reps is promoted to A.ndim by **pre-pending** 1’s to it.

## dict.items
	dict.items(): Return a copy of the dictionary’s list of (key, value) pairs.  
	dict.iteritems(): Return an iterator over the dictionary’s (key, value) pairs.

## dict.sort
	sorted(dic.items(), key=operator.itemgetter(0)) #按键排序  
	sorted(dic.items(), key=operator.itemgetter(1)) #按值排序  
	sorted(dic.items(), key=lambda t:t[0]) #按键排序  
	sorted(dic.items(), key=lambda t:t[1]) #按值排序  
	#sorted(iterable, cmp=None, key=None, reverse=False)

## sorted
	sorted(obj, key=operator.attrgetter("attr")) #按属性排序
	sorted(obj, key=lambda t.attr)				 #按属性排序

## dict(list)
列表转字典，字典是无序的，无法保持原有顺序  

	lst = [('c', 3), ('b', 4), ('d', 5), ('a', 7)]
	dic = dict(lst)
	<dic:{'a': 7, 'b': 4, 'c': 3, 'd': 5}>
	
## operator
	operator.itemgetter 按位置获取元素
	operator.attrgetter 按属性获取元素
	
## zip
zip([iterable...])：接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple，然后返回由这些tuples组成的list（可迭代对象）。

## map
map(function, iterable,...)：会根据提供的函数对指定序列做映射，每个参数的序列元素数量不一样，会根据最少元素的序列进行。

	listx = [1,2,3,4,5,6,7]       # 7 个元素
	listy = [2,3,4,5,6,7]         # 6 个元素 
	listz = [100,100,100,100]     # 4 个元素
	list_result = map(lambda x,y,z : x**2 + y + z,listx, listy, listz)
	print(list(list_result))

## filter
filter(function, iterable)：函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。
	
	def is_odd(n):
		return n % 2 == 1
	newlist = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
	print(newlist)

## reduce
reduce(function, iterable[, initializer])：函数将一个数据集合（链表,元组等）中的所有数据进行下列操作，用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作,,得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。在Python3 中，reduce()函数已经被从全局名字空间里移除了,它现在被放置在 fucntools 模块里。

	def add(x, y) :            # 两数相加
		return x + y
	reduce(add, [1,2,3,4,5])   # 计算列表和：1+2+3+4+5

## iter
iter(object[, sentinel])：函数用来生成迭代器。如果传递了第二个参数，则参数 object 必须是一个可调用的对象（如,函数），此时，iter 创建了一个迭代器对象，每次调用这个迭代器对象的__next__()方法时，都会调用 object。当返回值是sentinel是抛出StopIteration异常。

	lst = [1, 2, 3]
	for i in iter(lst): print(i)

## itertools
### itertools.count
	count(start=0, step=1)：从0开始，步长为n的无限迭代器
### itertools.cycle
	cycle(object): 无限循环迭代器,如cycle("ABC")
### itertools.repeat
	repeat(object, times)：把一个元素无限重复下去，第二个参数可限定重复次数.
### itertools.groupby
	groupby(iterable, key = keyfunction)：将iterable按keyfunction返回的结果进行分组。
	
	d1={'name':'zhangsan','age':20,'country':'China'}
	d2={'name':'wangwu','age':19,'country':'USA'}
	d3={'name':'lisi','age':22,'country':'JP'}
	d4={'name':'zhaoliu','age':22,'country':'USA'}
	d5={'name':'pengqi','age':22,'country':'USA'}
	d6={'name':'lijiu','age':22,'country':'China'}
	lst=[d1,d2,d3,d4,d5,d6]
	lst.sort(key=itemgetter('country')) #需要先排序，然后才能groupby
	lstg = groupby(lst,itemgetter('country')) 
	#lstg = groupby(lst,key=lambda x:x['country']) 等同于使用itemgetter()
	for key, group in lstg:
		for g in group:  #group是一个迭代器
			print key, g
	
	OutPut:
	China {'country': 'China', 'age': 20, 'name': 'zhangsan'}
	China {'country': 'China', 'age': 22, 'name': 'lijiu'}
	JP {'country': 'JP', 'age': 22, 'name': 'lisi'}
	USA {'country': 'USA', 'age': 19, 'name': 'wangwu'}
	USA {'country': 'USA', 'age': 22, 'name': 'zhaoliu'}
	USA {'country': 'USA', 'age': 22, 'name': 'pengqi'}
	