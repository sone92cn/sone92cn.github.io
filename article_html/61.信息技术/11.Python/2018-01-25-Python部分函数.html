<article><p style="text-indent:0em;"><a id="view_head" href="javascript:viewHead('#content_1');">返回</a></p><h2>numpy.tile:</h2>
<p>numpy.tile(A, reps):Array Copy
If reps has length d, the result will have dimension of <strong>max(d, A.ndim)</strong>;If <strong>A.ndim &lt; d</strong>, A is promoted to be d-dimensional by <strong>prepending</strong> new axes;If <strong>A.ndim &gt; d</strong>, reps is promoted to A.ndim by <strong>pre-pending</strong> 1’s to it.</p>
<h2>dict.items</h2>
<pre><code>dict.items(): Return a copy of the dictionary’s list of (key, value) pairs.  
dict.iteritems(): Return an iterator over the dictionary’s (key, value) pairs.
</code></pre>
<h2>dict.sort</h2>
<pre><code>sorted(dic.items(), key=operator.itemgetter(0)) #按键排序  
sorted(dic.items(), key=operator.itemgetter(1)) #按值排序  
sorted(dic.items(), key=lambda t:t[0]) #按键排序  
sorted(dic.items(), key=lambda t:t[1]) #按值排序  
#sorted(iterable, cmp=None, key=None, reverse=False)
</code></pre>
<h2>sorted</h2>
<pre><code>sorted(obj, key=operator.attrgetter("attr")) #按属性排序
sorted(obj, key=lambda t.attr)               #按属性排序
</code></pre>
<h2>dict(list)</h2>
<p>列表转字典，字典是无序的，无法保持原有顺序  </p>
<pre><code>lst = [('c', 3), ('b', 4), ('d', 5), ('a', 7)]
dic = dict(lst)
&lt;dic:{'a': 7, 'b': 4, 'c': 3, 'd': 5}&gt;
</code></pre>
<h2>operator</h2>
<pre><code>operator.itemgetter 按位置获取元素
operator.attrgetter 按属性获取元素
</code></pre>
<h2>zip</h2>
<p>zip([iterable...])：接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple，然后返回由这些tuples组成的list（可迭代对象）。</p>
<h2>map</h2>
<p>map(function, iterable,...)：会根据提供的函数对指定序列做映射，每个参数的序列元素数量不一样，会根据最少元素的序列进行。</p>
<pre><code>listx = [1,2,3,4,5,6,7]       # 7 个元素
listy = [2,3,4,5,6,7]         # 6 个元素 
listz = [100,100,100,100]     # 4 个元素
list_result = map(lambda x,y,z : x**2 + y + z,listx, listy, listz)
print(list(list_result))
</code></pre>
<h2>filter</h2>
<p>filter(function, iterable)：函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。</p>
<pre><code>def is_odd(n):
    return n % 2 == 1
newlist = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
print(newlist)
</code></pre>
<h2>reduce</h2>
<p>reduce(function, iterable[, initializer])：函数将一个数据集合（链表,元组等）中的所有数据进行下列操作，用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作,,得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。在Python3 中，reduce()函数已经被从全局名字空间里移除了,它现在被放置在 fucntools 模块里。</p>
<pre><code>def add(x, y) :            # 两数相加
    return x + y
reduce(add, [1,2,3,4,5])   # 计算列表和：1+2+3+4+5
</code></pre>
<h2>iter</h2>
<p>iter(object[, sentinel])：函数用来生成迭代器。如果传递了第二个参数，则参数 object 必须是一个可调用的对象（如,函数），此时，iter 创建了一个迭代器对象，每次调用这个迭代器对象的__next__()方法时，都会调用 object。当返回值是sentinel是抛出StopIteration异常。</p>
<pre><code>lst = [1, 2, 3]
for i in iter(lst): print(i)
</code></pre>
<h2>itertools</h2>
<h3>itertools.count</h3>
<pre><code>count(start=0, step=1)：从0开始，步长为n的无限迭代器
</code></pre>
<h3>itertools.cycle</h3>
<pre><code>cycle(object): 无限循环迭代器,如cycle("ABC")
</code></pre>
<h3>itertools.repeat</h3>
<pre><code>repeat(object, times)：把一个元素无限重复下去，第二个参数可限定重复次数.
</code></pre>
<h3>itertools.groupby</h3>
<pre><code>groupby(iterable, key = keyfunction)：将iterable按keyfunction返回的结果进行分组。

d1={'name':'zhangsan','age':20,'country':'China'}
d2={'name':'wangwu','age':19,'country':'USA'}
d3={'name':'lisi','age':22,'country':'JP'}
d4={'name':'zhaoliu','age':22,'country':'USA'}
d5={'name':'pengqi','age':22,'country':'USA'}
d6={'name':'lijiu','age':22,'country':'China'}
lst=[d1,d2,d3,d4,d5,d6]
lst.sort(key=itemgetter('country')) #需要先排序，然后才能groupby
lstg = groupby(lst,itemgetter('country')) 
#lstg = groupby(lst,key=lambda x:x['country']) 等同于使用itemgetter()
for key, group in lstg:
    for g in group:  #group是一个迭代器
        print key, g

OutPut:
China {'country': 'China', 'age': 20, 'name': 'zhangsan'}
China {'country': 'China', 'age': 22, 'name': 'lijiu'}
JP {'country': 'JP', 'age': 22, 'name': 'lisi'}
USA {'country': 'USA', 'age': 19, 'name': 'wangwu'}
USA {'country': 'USA', 'age': 22, 'name': 'zhaoliu'}
USA {'country': 'USA', 'age': 22, 'name': 'pengqi'}
</code></pre></article>